---
layout: post
title: "堆排序专区"
date: 2023-08-11 
description: "排序、堆排序"

tag: 排序
---  

手写了一个堆排序，下文代码展示的是小顶堆排序

思路如下：

1.建堆，可以通过数组模拟二叉树建堆，找到最后一个非叶子节点后自顶向下进行堆化

2.通过提供pop、insert，我们需要调整堆排序，pop时我们将堆顶元素与最后一个元素交换，再自顶向下进行堆化，insert时我们将插入到末尾，自下向上进行堆化

```java
package algorithm.sort;

import java.util.Arrays;

/**
 * 功能描述: 堆排序
 *
 * @author lzsusc2019
 * @since 2023-08-11
 */
public class heapSort {

    public static int[] arr = {1, 10, 9, 22, 31, 15, 40, 25, 91};

    // 建立小顶堆
    public static void main(String[] args) {
        buildHeap();
        for (int num : arr) {
            System.out.println(num);
        }
        System.out.println("-----------");
        int removeValue = pop();
        System.out.printf("pop value: %d\n", removeValue);
        for (int num : arr) {
            System.out.println(num);
        }
        System.out.println("-----------");
        insert(2);
        for (int num : arr) {
            System.out.println(num);
        }
    }

    public static void buildHeap() {
        int lastNonLeaf = (arr.length - 2) / 2;
        for (int i = lastNonLeaf; i >= 0; i--) {
            siftDown(i);
        }
    }

    // 堆化，自顶向下
    public static void siftDown(int index) {
        int len = arr.length;
        int leftIndex = index * 2 + 1;
        int rightIndex = index * 2 + 2;
        int swapIndex = index;
        if (leftIndex < len && arr[leftIndex] < arr[swapIndex]) {
            swapIndex = leftIndex;
        }
        if (rightIndex < len && arr[rightIndex] < arr[swapIndex]) {
            swapIndex = rightIndex;
        }
        if (swapIndex != index) {
            swap(swapIndex, index);
            siftDown(swapIndex);
        }
    }

    private static void swap(int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // 堆化，自下向上
    public static void siftUp(int index) {
        int parentIndex = (index - 1) / 2;
        int swapIndex = index;
        if (parentIndex >= 0 && arr[index] < arr[parentIndex]) {
            swapIndex = parentIndex;
        }
        if (swapIndex != index) {
            swap(swapIndex, index);
            siftUp(swapIndex);
        }
    }

    // 提供调用的api pop, insert
    public static int pop() {
        int value = arr[0];
        int len = arr.length;
        swap(0, len - 1);
        arr = Arrays.copyOfRange(arr, 0, len - 1);
        siftDown(0);
        return value;
    }

    public static void insert(int value) {
        // 增加元素到末尾
        arr = Arrays.copyOf(arr, arr.length + 1);
        int len = arr.length;
        arr[len - 1] = value;
        // siftUp
        siftUp(len - 1);
    }
}
```



