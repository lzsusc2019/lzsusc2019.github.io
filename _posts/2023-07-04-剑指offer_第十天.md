---
layout: post
title: "剑指offer_第十天"
date: 2023-07-04 
description: "二叉树"

tag: 算法
---  

## 二叉树前序遍历

### 1、题意

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

示例1：

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

示例2：

```
输入：root = []
输出：[]
```

### 2、题目解析

``解法1``

递归法

``解法2``

迭代法

### 3、参考代码

**解法1**

```java
class Solution {
	public List<Integer> result = new ArrayList<>();
    
    public List<Integer> preorderTraversal(TreeNode root) {
        // 设置一个数组保存二叉树的前序遍历结果
        if (root == null) 
            return result;
        result.add(root.val);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return result;
    }
}
```

**解法2**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        // 设置一个数组保存二叉树的前序遍历结果
        List<Integer> result = new ArrayList<>();
        // 判空操作
        if (root == null) 
            return result;
        //设置一个栈
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        // 循环遍历栈
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            // 先加入右节点
            if (node.right != null) stack.push(node.right);
            // 再加入左节点
            if (node.left != null) stack.push(node.left);
        }
        return result;
    }
}
```

## 二叉树后序遍历

### 1、题意

给你二叉树的根节点 `root` ，返回它节点值的 **后序** 遍历。

示例1：

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

示例2：

```
输入：root = []
输出：[]
```

### 2、题目解析

``解法1``

递归法，都类似就不贴出来了

``解法2``

迭代法

### 3、参考代码

**解法2**

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        // 设置一个数组保存二叉树的前序遍历结果
        List<Integer> result = new ArrayList<>();
        // 判空操作
        if (root == null) 
            return result;
        //设置一个栈
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        // 循环遍历栈
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            // 先加入左节点
            if (node.left != null) stack.push(node.left);
            // 先加入右节点
            if (node.right != null) stack.push(node.right);
        }
        // result结果为 中右左
        // 需要再反转一下即可
        return Collections.reverse(result);
    }
}
```

## 二叉树中序遍历

### 1、题意

给你二叉树的根节点 `root` ，返回它节点值的 **中序** 遍历。

示例1：

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

示例2：

```
输入：root = []
输出：[]
```

### 2、题目解析

中序遍历与前序、后序的区别在于，中序遍历存在遍历节点与处理节点不一致的问题，所有在迭代法中，通过引入指针来实现遍历

``解法1``

递归法，都类似就不贴出来了

``解法2``

迭代法

### 3、参考代码

**解法2**

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        // 需要借助一个指针来实现遍历节点与处理节点不一致的问题
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                // 弹出加入的第一个左节点
                cur = stack.pop();
                result.add(cur.val);
                // 看看右节点是否为空，为空继续弹出，不为空加入到栈中
                cur = cur.right;
            }
        }
    }
}
```



```
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        // 需要借助一个指针来实现遍历节点与处理节点不一致的问题
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                // 弹出加入的第一个左节点
                cur = stack.pop();
                result.add(cur.val);
                // 看看右节点是否为空，为空继续弹出，不为空加入到栈中
                cur = cur.right;
            }
        }
    }
}
```









