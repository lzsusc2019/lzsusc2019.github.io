---
layout: post
title: "笔记"
date: 2023-06-20 
description: "个人笔记"

tag: hexo
---  

**注意点**

修改需要主键  直接用*吧


    System.out.println("---------------------");

开启终端  CRTL + ALT + T





​    

今日优化：

新增订单页日期查询

新增、修改订单单体的下拉框

发现一个bug,修改订单单体名称不会修改库存，已修复

解决昨日bug,盘点单同类型商品名应该合并记录，并覆盖之前记录





java编程思想

自研框架源码

tomcat    初始化 ->加载 -> 渲染   前端->后端        

spring springmvc mybatis 源码



今日任务：

1.了解需求

2.熟悉需求相关的业务逻辑











发票号码获取路径 ：  销售发票管理.销售单号  -> 对账单号  ->  发票号码 

汇率：  

```java
1.新增点击事件，在`备货单`->相关操作下新增 “佳仁定制提成报表”
  TFrmTranSN.initRightSide  
2.字段
销售计划日期、发票号码、管理编号、品名、描述、单位、销售单价、销售总额、汇率、人民币总额、业务员提成、采购员提成
3.发票号码、品名  跳转
3.header查询
4.左侧数据导出、[导入、数据合计]不知道要不要做
```



销售单菜单,点击销售单号,能获取全部信息，是否可以直接调用`查看销售单`的信息？

表名：

销售单-单头 TranB1H

销售单-单身 TranB1B

商品基本资料表 PartInfo

备货单 scanbct

```
p.PartType_ 商品类型
p.EnSpec_   英文规格
p.EnDesc_   英文品名



```

![image-20230222100000387](/home/admin/.config/Typora/typora-user-images/image-20230222100000387.png)



```
select Name 
from s_userinfo
where Code_ = '1310010010'

tranb1h 的SalesCode_

```





销售出单 -> 准备货物  -> 卖家确认 

采购订单 -> 提取货物  -> 买家确认



 

计划交期     ordb.OutDate_

管理编号没问题，商品也没啥问题了



​    

​    















```
        // 发票号
        /*
         * MysqlQuery invoiceNo = new MysqlQuery(this);
         * invoiceNo.add("select h.InvoiceNo_,h.CusCode_"); invoiceNo.add("from %s h",
         * AppDB.Table_CR_Invoice_H);
         * invoiceNo.add("inner join %s c on h.CorpNo_=c.CorpNo_ and h.TBNo_=c.TBNo_ ",
         * AppDB.Table_CR_Invoice_B);
         * 
         * SqlWhere where = invoiceNo.addWhere(); where.eq("h.CorpNo_", getCorpNo());
         * where.in("h.TBNo_", TBNo_); if (headIn.has("InvoiceNo_")) {
         * where.eq("h.InvoiceNo_", headIn.getString("InvoiceNo_")); } where.build();
         * invoiceNo.open();
         */
```





CUSTOMER_224005



partstock 表    PlanNum_   字段





PurB.Approval_   1 已审核  0未审核





ScanBCT    ScanStatus_=3   备货完成



```
需要修改的点

where h.CorpNo_='%s' and t.Status_=1 and t.ScanStatus_=3


```





1.补充采购员，【采购员】取值销售订单所管理的【采购订单】建档人员

2.修改销售人员为业务人员 √

3.添加业务人员和采购员的条件查询  

4.将计划日期改成计划交期  √

5.



![image-20230223170250419](/home/admin/.config/Typora/typora-user-images/image-20230223170250419.png)

scanbct  Remark_



![image-20230224160153084](/home/admin/.config/Typora/typora-user-images/image-20230224160153084.png)

1.增加批号登记显示

2.按等级查询功能



库存管理

调拨单、盘点单 属于同一个地方

![image-20230224155948978](/home/admin/.config/Typora/typora-user-images/image-20230224155948978.png)

增加等级及等级查询条件





```
        MysqlQuery ds = new MysqlQuery(handle);
        ds.add("select tlt.InNum_,tlt.OutNum_,tlt.SurplusNum_,tlt.LotNo_,tlt.PartCode_,p.Desc_,p.Spec_,");
        ds.add("p.Unit_,tlt.ProductionDate_,p.WarrantyDay_,p.Volume_");
        if (CustomerList.CUSTOMER_224023.equals(handle.getCorpNo())) {
            ds.add(",d.Reject_,d.Cause_");
        }
        ds.add("from %s tlt", AppDB.Table_LotNo_Total);
        ds.add("inner join %s p on tlt.CorpNo_=p.CorpNo_ and tlt.PartCode_=p.Code_", AppDB.getPartInfo);
        if (CustomerList.CUSTOMER_224023.equals(handle.getCorpNo())) {
            ds.add("left join %s d on d.CorpNo_=tlt.CorpNo_ and d.LotNo_=tlt.LotNo_", AppDB.Table_Proday_Detail);
        }
```



```
OptionField fdReject = new OptionField(search, "等级", "Reject_");
fdReject.put("", "所有等级");
fdReject.put("1", "A等");
fdReject.put("2", "B等");
fdReject.put("3", "C等");
fdReject.put("4", "废品");
```



单据变跟单

```
保存 / 作废(删除) / 生效


保存  -> 新增到表
生效  -> 状态修改
作废  -> 状态修改

```



```sql
CREATE TABLE `ord_bill` (
  `UID_` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `CorpNo_` varchar(10) NOT NULL COMMENT '企业编号',
  `TBNo_` varchar(20) NOT NULL COMMENT '销售订单单号',
  `Num_` decimal(18,4) NOT NULL COMMENT '数量',
  `Amount_` decimal(18,4) NOT NULL COMMENT '总金额',
  `OutDate_` datetime NOT NULL COMMENT '订单交期',
  `Status_` int(11) NOT NULL DEFAULT '1' COMMENT '状态',
  `UpdateUser_` varchar(10) DEFAULT NULL COMMENT '更新人员',
  `UpdateDate_` datetime DEFAULT NULL COMMENT '更新时间',
  `AppUser_` varchar(10) NOT NULL COMMENT '建档人员',
  `AppDate_` datetime NOT NULL COMMENT '建档时间',
  PRIMARY KEY (`UID_`),
  KEY `IX_OrdBill_1` (`CorpNo_`,`TBNo_`),
) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='销售订单-变更单据';

Table_OrdBill
```

















菜单注册后，菜单的订购类型默认给标准菜单，而我们去应用商店注册时，搜索出来的是订购类型为应用商店的类型，导致搜索不出来，从而无法注册到表中。表中记录有redis做缓存，之前直接插入表中的方式没有生效，因为redis存在一个小时的过期时间，导致当时无法看到权限控制效果。







1. AOF



1. AOF写入流程缓冲区  -> 系统调用 -> 内核缓冲区  -> 由配置项决定何时写入硬盘中  
2. AOF满了，会触发AOF重写机制

2.1 重写时，又有新key添加到库中，如何解决的？

重写AOF是由后台的子进程完成的，使用了父子进程的写时复制技术。

为什么这么设计？

此处没有采用多线程来实现，主要考究的是对性能的影响，多线程间是共享进程的内存的，当出现读写时需要加锁，而写时复制技术避免了线程间切换上下文的开销。写时复制技术其实是一种优化技术，在父进程创建子进程时，操作系统不会真正复制父进程的内存空间，而是将子进程的地址空间指向父进程的地址空间，只有在父进程或子进程需要修改内存时，才会进行复制操作。

这样操作下，主进程内存中是会与子进程内存中产生数据不一致

为了解决这个问题，redis设置了AOF重写缓冲区，再重写期间新增的key既会写入AOF缓冲区，也会写入AOF重写缓冲区。等待重新完成后，子进程会向父进程发送信号。主进程收到信号会将AOF重写缓冲区的数据追加到新的AOF文件中，再覆盖掉现有的AOF文件。

2.2 



AOF故障恢复是单线程写入，且AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。